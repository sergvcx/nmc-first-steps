[[]]


= 1.1 Урок 1: Простейшая Программа на Языке Ассемблера 
Исходный текст примера, используемого в данном уроке, содержится в файле `step1.asm` в каталоге: `..\steps-risc\step01`.
Пример загружает в регистры общего назначения пару констант, затем складывает содержимое регистров и передаёт сумму в качестве возвращаемого значения.


*Файл “step1.S”*
[code,asm]
----
include::step1.S[]
----


== Комментарии к Примеру
Пример начинается с объявления глобальной (`global`) метки `__main`, которая будет в данном случае определять адрес в памяти той команды, с которой начинается тело основной программы. 
Объявление метки может происходить в любом месте ассемблерного файла, однако для лучшей читаемости кода рекомендуется выносить его за пределы секций.
Метка `__main`  особенная (два подчёркивания перед словом `main` обязательны), так как она является меткой начала пользовательской программы. Функция с этим именем вызывается из кода начальной инициализации, автоматически добавляемого к любой пользовательской программе при компиляции (об этом см. ниже).
За объявлением глобальной  метки следует секция кода. Секция кода начинается с открывающей скобки `begin` и заканчивается закрывающей скобкой `end`. Имена секций при открывающей и закрывающей скобках должны совпадать.
`begin ".textAAA"`
`...`
`end ".textAAA";`



[NOTE]
====
Примечание 
Рекомендуется имя секции кода начинать с префикса text, например: «textMyCodeSection».  Дизассемблер (программа dump.exe),  разбирая первые символы имени секции, поймёт, что это код программы и представит её содержимое в виде дизассемблированных инструкций. В противном случае он оставит содержимое секции в виде бинарного кода.
====


За открывающей скобкой `begin “.textAAA”` следует определение метки: 
`__main:`
Метка помечает ту команду, которая следует после нее до ближайшей `";"`. В приведённом выше примере меткой помечается инструкция `gr0 = 1;`.
Инструкции: 

[code,asm]
----
gr0 = 1;   
gr1 = 2;  
----
представляют собой команды инициализации константой регистров общего назначения `gr0` и `gr1`.
Инструкция:
`gr7 = gr0 + gr1;`
выполняет арифметическую операцию суммирования содержимого регистров `gr1` и `gr2`, а результат заносит в регистр `gr7`.
Регистр `gr7` используется для хранения возвращаемого значения при выходе из функции.
Тело программы заканчивается командой возврата из подпрограммы: 
`return`;
Последней строкой примера стоит закрывающая скобка секции кода.

== Компиляция Примера
Для компиляции данного примера необходимо в командной строке ввести команду: 
`nmcc -g step1.asm libc.lib -m`
Программа nmcc представляет собой специальную оболочку (shell), упрощающую процесс запуска компилятора. Она автоматически определяет, какой набор системных компонент необходимо вызвать для сборки исполняемого файла.
Параметры `nmcc` могут располагаться в произвольном порядке. Параметр `–g` включает отладочную информацию в выходной файл. Параметр `–m` включает порождение файла-карты памяти, где показано, какой объём памяти отведён под те или иные секции кода и данных, каковы их адреса, приводит список глобальных переменных и т.д.
Для того чтобы компиляция примера `step1.asm` прошла успешно, в командную строку добавлен файл `libc.lib`. Это библиотека времени выполнения Си. В библиотеке содержится стартовый код программы, определена точка входа `start`. Стартовый код позволяет выполнять и отлаживать программу при помощи набора утилит, входящих в состав SDK. В частности, там содержится код останова, куда программа приходит по окончании выполнения. Именно по выполнению этого кода утилиты, запустившие программу на исполнение, понимают, что программа завершена.

[WARNING]
====
Внимание	Библиотека `libc.lib` добавляется автоматически, если при компиляции в командной строке встречается файл с расширением `*.cpp`. Если же программа собрана только из ассемблерных файлов, библиотека `libc.lib` должна быть добавлена вручную.
====

Если в командной строке не указано имя выходного файла, то его имя будет сформировано по имени первого встреченного файла. В рассматриваемом примере первым расположен файл `step1.asm`, поэтому в результате компиляции исполняемый код программы будет сохранён в файле `step1.abs`.

== Запуск Программы на Симуляторе
Полученный файл `step1.abs` может быть выполнен на симуляторе (программа `emurun.exe`). Эта программа представляет собой программный эмулятор на уровне инструкций. Она выполняет программу, и в строке
`Step1.abs:: WARNING: return 3 = 0x3`
отображает значение, возвращаемое пользовательской программой. Такая строка появляется всегда, когда функция `main()` возвращает ненулевое значение.

== Отладка Программы на Символьном Отладчике
Для загрузки программы в символьный отладчик надо дважды нажать мышкой на иконку с именем пользовательской программы. Программа автоматически будет загружена в `emudbg` и остановится на точке входа в готовности выполнить первую инструкцию стартового кода.
Рис. 1 1. Внешний Вид Символьного Отладчика EMUDBG
 
Для того чтобы перейти к отладке строк пользовательской программы, необходимо в меню ВИД | ИСХОДНЫЕ ТЕКСТЫ выбрать файл с исходным текстом, установить курсор на строку, начиная с которой вы собираетесь вести отладку и нажать на панели инструментов кнопку   (шаг к курсору).
Далее отладка ведётся привычным способом. Вся информация о процессе выполнения (состояние регистров, содержимое областей памяти и т.д.) может быть получена путём открытия соответствующих диалоговых окон отладчика.
