= Простейшая Программа на Языке Ассемблера 
Исходный текст примера, используемого в данном уроке, содержится в файле `step1.S` в каталоге: 
`\steps-risc\step01`.

Пример загружает в регистры общего назначения пару констант, затем складывает содержимое регистров и передаёт сумму в качестве возвращаемого значения.


*Файл “step1.S”*
[code.S]
----
include::step1.S[]
----


== Комментарии к Примеру
Пример начинается с объявления глобальной (`.global`) метки `\__main`, которая будет в данном случае определять адрес в памяти той команды, с которой начинается тело основной программы. 
Объявление метки может происходить в любом месте ассемблерного файла, однако для лучшей читаемости кода рекомендуется выносить его за пределы секций.
Метка `__main`  особенная (два подчёркивания перед словом `main` обязательны), так как она является меткой начала пользовательской программы. Функция с этим именем вызывается из кода начальной инициализации, автоматически добавляемого к любой пользовательской программе при компиляции (об этом см. ниже).
За объявлением глобальной  метки следует секция кода. Секция кода начинается с открывающей скобки `.text`. Данная запись является сокращением полного объявления секции 
`.section .text`.



[NOTE]
=====
Рекомендуется имя секции кода начинать с префикса `.text`, например: `.section .text.MyCodeSection`. В случае если имя секции имеет префикс `.text`  дизассемблер (программа `nmc-objdump`),  разбирая первые символы имени секции, поймёт, что это код программы и представит её содержимое в виде дизассемблированных инструкций. В противном случае он оставит содержимое секции в виде бинарного кода.

=====


За объявлением секции кода `.text` следует определение метки: 
`__main:`
Метка помечает ту команду, которая следует после нее до ближайшей `";"`. В приведённом выше примере меткой помечается инструкция `gr0 = 1;`.  

Инструкции: 
[code.S]
----
gr0 = 1;   
gr1 = 2;  
----
представляют собой команды инициализации константой регистров общего назначения `gr0` и `gr1`.
Инструкция:
`gr7 = gr0 + gr1;`
выполняет арифметическую операцию суммирования содержимого регистров `gr1` и `gr2`, а результат заносит в регистр `gr7`.
Регистр `gr7` используется для хранения возвращаемого значения при выходе из функции.
Тело программы заканчивается командой возврата из подпрограммы: 
`return;`
Последней строкой примера стоит закрывающая скобка секции кода.


=== Запуск Программы на Симуляторе
Полученный файл `test.abs` может быть выполнен на симуляторе (программа `nmc-qemu`). Эта программа представляет собой программный эмулятор на уровне инструкций. Она выполняет программу, и в строке
`Simulation error! Return value 3`
отображает значение, возвращаемое пользовательской программой. Такая строка появляется всегда, когда функция `main()` возвращает ненулевое значение. Если же функция возвращает нуль, то результатом будет строка
`Successful end of simulation!`


```
c:\Module\MC12101\examples\first-steps\steps-risc\step01\qemu>make run
nmc-qemu test.abs

Simulation error! Return value 3
make: *** [run] Error 1
```

=== Отладка Программы на GDB-Отладчике

При отладке программы через GDB из командной строки значение регистров можно вывести с помощью команды `p` или `print` .
Например 

```
(gdb) b main
Breakpoint 1 at 0x25e: file ../step1.S, line 5.
(gdb) c
Continuing.

Breakpoint 1, main () at ../step1.S:5
5           gr0 = 1;         
(gdb) n
6           gr1 = 2;         
(gdb) n
7           gr7 = gr0 + gr1; 
(gdb) n
8           return;
(gdb) p $gr7
$1 = 3
(gdb) c
Continuing.
```

Вывести список всех доступных регистров можно командой `info registers`

В среде VSCODE вывести значение регистров можно в окне `Registers`, либо  `Watch` также задав имя регистра после `$`.