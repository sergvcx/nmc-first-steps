= Оптимизация Выполнения Цикла
Исходный текст примера, используемого в данном уроке, содержится в файле `step3a.S` в каталоге: 
`\steps-risc\step03a`.

Пример демонстрирует, как может быть оптимизирован цикл, описанный в предыдущем уроке. 

*Файл “step3a.S”*
[code.S]
----
include::step3a.S[]
----


== Комментарии к Примеру
В языке ассемблера введено два типа команд перехода. К первому относятся команды обычного перехода, ко второму отложенного. Такое разделение введено искусственно, для удобства программирования. 
От момента выбора команды перехода и до того, как состоится реальный переход проходит от одного до трёх тактов. За это время процессор успевает выбрать дополнительно одну три инструкции, следующих непосредственно за инструкцией перехода. Назовём такие инструкции отложенными. Формализованный подход к определению точного количества отложенных инструкций, описан в приложении A.1.Типы Команд Перехода данного документа. 
Упрощённая схема выполнения перехода подразумевает, что компилятор сам рассчитывает количество отложенных инструкций и заполняет их  пустыми командами (`nul`). Если программист для выполнения перехода использует инструкцию без ключевого слова `delayed`, например:
`if > goto Loop;`
то две инструкции `nul` будут автоматически добавлены  компилятором. 
Если же программист захочет осмысленно использовать отложенные инструкции, то в команду перехода должно быть добавлено ключевое слово `delayed`. В конкретном примере после инструкции 
`if > delayed goto Loop with gr1--;`
будут выполнены две отложенные инструкции: 
```
[ar0++] = gr0 with gr0++ noflags;
null;
```
Отложенные инструкции выполняются в любом случае, независимо от того, выполнилось условие перехода или нет. 
Рассмотрим подробнее сам цикл. Как уже отмечалось, он состоит из инструкции условного перехода и следующих за ней двух отложенных инструкций. При первом вхождении в цикл инструкция
`if > delayed goto Loop with gr1--;`
производит проверку флагов, выставленных предыдущей арифметической операцией, а именно: gr1--. При этом в правой части инструкции выполняется вычитание, которое выставляет флаги для проверки на следующем цикле. 
Для того чтобы предотвратить модификацию флагов в отложенных командах, после арифметической операции используется служебное слово `noflags`. Оно запрещает процессору менять флаги. 


