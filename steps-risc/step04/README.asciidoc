= Копирование Массива Данных на Скалярном Процессоре
Исходный текст примера, используемого в данном уроке, содержится в файле `step4.S` в каталоге: `\steps-risc\step04`.
Пример демонстрирует два способа копирования массива 64-разрядных слов на скалярном процессоре. Первый способ – простое копирование, второй – копирование при помощи регистровых пар.

*Файл “step4.S”*
[code.S]
----
include::step4.S[]
----


== Комментарии к Примеру
В первой части примера копирование данных осуществляется через один 32-х разрядный регистр. На первом шаге в регистр заносится слово из памяти, на втором оно копируется из регистра в память по другому адресу. В данном случае значения адресных регистров каждый раз увеличиваются на единицу. Поскольку необходимо скопировать массив из шестнадцати 64-х разрядных слов, а за один цикл копирования через регистр переносится одно 32-х разрядное число (младшая или старшая половина 64-х разрядного слова), то для того, чтобы скопировать весь массив необходимо выполнить тридцать два цикла. 
Во второй части примера копирование происходит через регистровую пару `ar2`, `gr2` (в регистровой паре каждому адресному регистру поставлен в соответствие регистр общего назначения с тем же номером). За один цикл чтения/записи переносится целиком 64 разрядное слово, поэтому количество циклов копирования равно шестнадцати.  
При чтении из памяти в регистровую пару `ar2,gr2=  [ar0++];`
 
ВСЕГДА младшая часть 64-разрядного слова попадает в  `arX`, старшая – в `grX` независимо от того, в каком порядке перечислены регистры в паре. Те же правила действуют при записи содержимого регистровой пары в память. По младшему адресу всегда записывается содержимое регистра `arX`, по старшему - `grX`. Таким образом, команда `[ar1++] = gr2,ar2;` 

запишет данные в память в том же порядке, в каком они были считаны, независимо от того, в какой последовательности перечислены регистры регистровой пары. 
Другим важным моментом, на который стоит обратить внимание, является то, как изменяются значения адресных регистров, используемых для доступа к памяти. И в первой, и во второй части примера используется одна и та же форма записи для инкрементации регистров `ar0` и `ar1`. Однако в первой части, когда выполняется 32-х разрядный доступ к памяти, значения адресных регистров увеличиваются на единицу, а во второй на двойку.
Процессор автоматически распознаёт, какой тип доступа к памяти используется в заданной инструкции - 32-х или 64-х разрядный. Наличие в инструкции регистровой пары или 64-х разрядного регистра управления приводит к тому, что доступ к памяти ведётся 64-х разрядными словами. Но поскольку единица адресации - 32-х разрядное слово, то при 64-х разрядном доступе простая инкрементация адресного регистра приводит к увеличению его значения на два, например:
```
gr2 = [ar0++];     // ar0 увеличивается на 1
ar2,gr2 = [ar0++]; // ar0 увеличивается на 2
```



