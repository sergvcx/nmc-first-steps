.global _Mask          // объявляется глобальная метка _Mask
	
.section .data.my_data
    Temp: .quad 0x0

.text	
_Mask:	
    ar5 = ar7 - 2;    // сохраняется указатель стека
	
    push ar0, gr0;    // в стеке сохраняются регистровые пары
    push ar1, gr1;	
    push ar2, gr2;	
		
    ar0 = [--ar5];    // в ar0 загружается адрес массива
    gr0 = [--ar5];    // в gr0 загружается маска:  00000044h
		
    ar2 = ar0;        // адрес входного массива копируется в ar2
    gr1 = gr0 << 8;   // gr1 = 00004400
    gr0 = gr0 or gr1; // gr0 = 00004444
    gr1 = gr0 << 16;  // gr1 = 44440000
    gr1 = gr0 or gr1; // gr0 = 44444444
    ar1 = gr1;	
    // в переменную Temp записывается значение маски: 4444444444444444h,
    // при этом в регистр ar1 заносится адрес этой переменной.
    [ar1 = Temp] = ar1, gr1;
	
	
#if __NM4__== 0
    nb1 = 80808080h;	
#else
    sir = 80808080h;	
    nb1 = sir;
#endif

    wtw;	
    // регистр управления функцией активации, задаёт обработку вектора, подаваемого 
    // на операнд X векторного процессора.
    f1cr = 80808080h;	
		
    rep 32 ram = [ar0++];
    rep 32 data = [ar1] with ram - data;
	
    // применение логической функции активации к содержимому afifo.
    rep 32 with not activate afifo;
    // выполнение операции маскирования, маска хранится в afifo, в операнд X попадают 
    // данные с шины данных, в операнд Y данные из ram.
    rep 32 data = [ar1] with mask afifo, data, ram;
    // результат опреации сохраняется во внешней памяти.
    rep 32 [ar2++] = afifo;
	
    pop ar2, gr2;	  // восстановление регистровых пар из стека
    pop ar1, gr1;	
    pop ar0, gr0;	
    return;	
		
	
