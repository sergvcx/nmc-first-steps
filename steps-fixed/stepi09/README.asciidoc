= Операции Логической Активации и Маскирования на ВП
Исходный текст примера, используемого в данном уроке, содержится в файле `step9.S` в каталоге: `steps-fixed/stepi09`.
Пример демонстрирует выполнение операции логической активации и операции маскирования на векторном АЛУ. 

*Файл “main.cpp”*
[code,cpp]
----
include::main.cpp[]
----


*Файл “step9.S”*
[code.S]
----
include::step9.S[]
----


== Комментарии к Примеру
Функция `Mask` сравнивает значение каждого 8-разрядного элемента вектора со значением порога и при превышении заменяет его значением порога. Например, если в массиве был вектор `0x1122334455667788`, то после применения порога `0x44` к каждому его элементу, получится `0x1122334444444444`. 
На вход функции подаётся байтовый порог. Функция `Mask` содержит код, позволяющий по этим данным сформировать полноценный 64 разрядный вектор порога. 
```
gr1 = gr0 << 8;  // gr1= 00004400h 
gr0 = gr0 or gr1;// gr0 = 00004444h 
gr1 = gr0 << 16; // gr1 = 44440000h 
gr0 = gr0 or gr1;// gr0 = 44444444h
ar1 = gr1; // копирование содержимого gr1 в парный регистр ar1
[ar1 = Temp] = ar1,gr1;
```
Последняя команда копирует содержимое регистровой пары в память по адресу `Temp`, а затем заносит этот адрес в регистр `ar1`.
Новое понятие, вводимое в данном примере - регистр управления функцией активации `f1cr` (`f2cr`). Здесь рассматривается только логическая активация, арифметическая будет рассмотрена в следующем уроке.
Регистр `f1cr` используется для управления блоком активации, расположенным на пути данных, подаваемых на операнд X векторного процессора, регистр `f2cr` связан с операндом Y.
`SET f1cr , 0x80808080;`
определяет разбиение 64-разрядного слова, подаваемого на вход X ВП для обработки функцией активации, на 8 элементов по 8 бит. В общем случае это разбиение может не совпадать с тем, которое задается nb1. (Подробнее см. раздел 3.3.1 Регистры f1cr и f2cr Описания Языка Ассемблера для NM6403).
`rep 32 ram = [ar0++];` - вектора входных данных загружаются  в регистр-контейнер ram.
`rep 32 data = [ar1] with ram - data;` - на вход векторного АЛУ из памяти поступают тридцать два одинаковых вектора порогов и выполняется операция разности векторов данных и векторов порогов.
`rep 32 with not activate afifo;` - операция логической активации данных, попавших в `afifo` в результате вычитания. 
При выполнении логической активации процессор анализирует биты вектора входных данных расположенные в местах, где у регистра `f1cr` стоят ненулевые биты (см. Рис. <<fig-bit_propagation>>).

[#fig-bit_propagation]
.Распространение Знаковых Битов при Создании Маски
image::bit_propagation.png[image,width=608,height=479]


Если анализируемый бит равен единице, то вправо от него до следующего ненулевого бита `f1cr` все биты вектора результата заполняются единицей, если нуль, то биты справа заполняются нулём.
В данном случае над операндом дополнительно совершается операция отрицания. В результате байты, значение которых было меньше порога, превратились в 0, остальные в –1. Результат операции помещается в `afifo`. Операция отрицания выполняется на векторном АЛУ, поэтому она применяется к уже активированному вектору. Более подробно порядок выполнения преобразований на векторном процессоре описан в пункте 1.4.6 Порядок выполнения преобразований над данными на ВП документа NeuroMatrix NM6403. Описание Языка Ассемблера.
Результат активации, лежащий в `afifo`, затем используется для выполнения маскирования, по итогам которого все значения байтов исходного массива, превышающие порог заменяются значением порога. Суть операции маскирования приведена на Рис. <<fig-mask>>:

[#fig-mask]
.Распространение Знаковых Битов при Создании Маски
image::bit_mask.png[image,width=608,height=479]

Операция логического маскирования выполняется при вызове следующей инструкции:
`rep 32 data = [ar1] with mask afifo, data, ram;`
В данном случае вектора из afifo используются в качестве маски, данные, считываемые  из внешней памяти – операнд X, данные из `ram` – операнд Y. Над всеми наборами векторов, принимающих участие в вычислениях, выполняется преобразование:
`(X and MASK) or (Y and not MASK)`
Как видно из Рис. <<fig-mask>>, в тех позициях, на которых в маске стоят 1, в слово результата будут записаны элементы вектора с входа X, на остальные места попадут элементы вектора со входа Y. Таким образом, в те позиции, на которых в `afifo` стоят 1, будут записаны биты из `Temp` (регистр `ar1`), в тех позициях, на которых стоят 0, будут записаны биты из массива данных (`ram`). 
`rep 32 [ar2++] = afifo;` - результат сохраняется во внешней памяти.

