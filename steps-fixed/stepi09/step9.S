.global _Mask                  // объявляется глобальная метка _Mask
    
.p2align 3                      // директива для выравнивания секции по  чётному адресу.    
.section .data.my_data
    Temp: .quad 0x0

.macro SET reg,val
#if __NM4__== 0
    \reg = \val; 
#else
    sir = \val; 
    \reg = sir;   
#endif
.endm

.text    
_Mask:    
    ar5 = ar7 - 2;    // сохраняется указатель стека
    
    push ar0, gr0;    // в стеке сохраняются регистровые пары
    push ar1, gr1;    
    push ar2, gr2;    
        
    ar0 = [--ar5];    // в ar0 загружается адрес массива
    gr0 = [--ar5];    // в gr0 загружается маска:  00000044h
        
    ar2 = ar0;        // адрес входного массива копируется в ar2
    gr1 = gr0 << 8;   // gr1 = 00004400
    gr0 = gr0 or gr1; // gr0 = 00004444
    gr1 = gr0 << 16;  // gr1 = 44440000
    gr1 = gr0 or gr1; // gr0 = 44444444
    ar1 = gr1;    
    // в переменную Temp записывается значение маски: 4444444444444444h,
    // при этом в регистр ar1 заносится адрес этой переменной.
    [ar1 = Temp] = ar1, gr1;
    
    

    SET nb1, 80808080h

    wtw;    
    // регистр управления функцией активации, задаёт обработку вектора, 
    // подаваемого на операнд X векторного процессора.
    SET f1cr , 80808080h
        
    rep 32 ram = [ar0++];
    rep 32 data = [ar1] with ram - data;
    
    // применение логической функции активации к содержимому afifo.
    rep 32 with not activate afifo or 0;
    // выполнение операции маскирования, маска хранится в afifo, в 
    // операнд X попадают данные с шины данных, в операнд Y данные из ram
    rep 32 data = [ar1] with mask afifo, data, ram;
    // результат операции сохраняется во внешней памяти.
    rep 32 [ar2++] = afifo;
    
    pop ar2, gr2;      // восстановление регистровых пар из стека
    pop ar1, gr1;    
    pop ar0, gr0;    
    return;    
        
    
