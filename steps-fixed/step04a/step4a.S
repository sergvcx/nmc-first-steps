#include "printx.hs"
.global __main        // объявление глобальной метки.

.p2align 3	
.section .data.MyData // секция инициализированных данных
    // массив А из 16 32-разрядных слов заполняется начальными значениями

	.global A
	A: .long     0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
	
	
.p2align 3		
.section .bss.MyData1 // секция неинициализированных данных.
    .global B 
	B: .space 16<<2      // объявление массива из 16 32-разрядных слов// объявляется массив В из 16 32-разрядных слов
    .global C
	C: .space 16<<2      // объявление массива из 16 32-разрядных слов// объявляется массив С из 16 32-разрядных слов
	
	
.section .text.AAA    // начало секции кода.
__main:	
    // копирование массива данных с помощью скалярного процессора
    ar0 = A;	
    ar1 = B;	
    gr1 = 16;         // счётчик цикла (16 циклов для копирования 16-ти 32-bit слов)
    gr1--;            // устанавливается флаг для первого вхождения в цикл
		
Loop:	
    // если условие выполнено, осуществляется отложенный переход на метку Loop
    if > delayed goto Loop with gr1--;
    // чтение из памяти  32-разрядного слова
    gr2  = [ar0++];
    // запись в память 32-разрядного слова
    [ar1++] = gr2;



    // копирование массивов данных с помощью векторного процессора
    ar0 = A;	
    ar1 = C;	
    // массив А подаётся на векторное АЛУ и попадает в afifo без изменений
    rep 8 data = [ar0++] with data;
    // сохранение во внешней памяти содержимого afifo, заполненного предыдущей 
    // векторной инструкциеей.
	
	ar5 = ar1; // сохраняем адресс массива С
	
	rep 8 [ar1++] = afifo;
	
	
	PRINTF("Output\: \n")
	PRINTF1("C addr =%X\n",ar5)
	PRINTF2("[C]={%d,%d}\n",[ar5++],[ar5++])


	return;	

