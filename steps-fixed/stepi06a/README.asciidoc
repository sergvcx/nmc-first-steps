= Операция Взвешенного Суммирования (Продолжение 1)
Исходный текст примера, используемого в данном уроке, содержится в файле `step6a.S` в каталоге: `steps-fixed/stepi06a`.
Пример демонстрирует использование операции взвешенного суммирования для одновременного вычисления суммы и разности двух 32-х разрядных элементов вектора.

*Файл “step6a.S”*
[code.S]
----
include::step6a.S[]
----

== Комментарии к Примеру
Задачей данного примера является одновременное вычисление суммы и разности элементов 64-х разрядного вектора. Это вычисление выполняется на устройстве умножения векторного процессора при помощи операции взвешенного суммирования. Основная идея этого преобразования поясняется на Рис. <<fig-diff_sum>>:

[#fig-diff_sum]
.Вычисление Суммы и Разности Элементов Вектора 
image::diff_sum.png[image,width=608,height=479]

Для выполнения операции взвешенного суммирования необходимо заполнить матрицу весовых коэффициентов значениями. Но прежде требуется разбить матрицу на строки и столбцы.
Макрос `SET nb1, 0x80000000`; разбивает матрицу на 2 столбца. При этом в обе части регистра попадают одинаковые константы. Таким образом, в `nb1` содержится константа `8000000080000000hl`. 
Команда `sb = 03h`; разбивает матрицу на 2 строки. При этом в обе части регистра попадают одинаковые константы. Таким образом, в `sb` (64 разряда) содержится константа `0x0000000300000003`.  
Команда `rep 2 wfifo = [ar1++], ftw, wtw`; осуществляет загрузку весовых коэффициентов из памяти в регистр-контейнер `wfifo`. Как только первое слово весов попадёт в `wfifo`, сразу же начинается его перекодирование в формат теневой матрицы (эта операция задаётся командой `ftw`). По завершению перекодирования весов в формат теневой матрицы произойдёт копирование её содержимого в рабочую матрицу. Эта операция занимает один процессорный такт.
Инструкция
`rep 1 data = [ar2] with vsum , data, 0;`
выполняет взвешенное суммирование с коэффициентами, которые прежде были загружены в рабочую матрицу. Вычисление производится по схеме приведённой на Рис. <<fig-diff_sum>>. Результат операции попадает в регистр-контейнер afifo.
Инструкция 
`rep 1 [ar4] = afifo;`
выгружает результат из afifo во внешнюю память.


