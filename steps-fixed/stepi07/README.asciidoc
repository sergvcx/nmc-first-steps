= Вызов Ассемблерных Функций из Си++.
Начиная с данного урока все примеры оформлены в виде ассемблерных функций, вызываемых из основной программы, написанной на языке Си++. 
Исходный текст примера, используемого в данном уроке, содержится в файлах `main.cpp` и `step7.asm` в каталоге: `..\Tutorial\Step7`.
Пример демонстрирует вызов функции, написанной на языке ассемблера для NM6403, из программы на языке Си++. 

Файл “main.cpp”
[code,cpp]
----
extern "C" int Neg ( int value );

int main()
{
	int a = 16;	
	return Neg(a);	// вызов функции, выполняющей негативацию входного
					// параметра.
}
----

Файл “step7.S”
[code,asm]
----
.global _Neg    	// объявление метки с именем подпрограммы.
	
.text
_Neg:	
    ar5 = ar7 - 2;	// адреса в стеке для доступа к входным параметрам.
    push ar0, gr0;	// сохранение используемых в подпрограмме регистров.
		
    gr0 = [--ar5];	// получение значения входного параметра.
    gr7 = - gr0;	
		
    pop ar0, gr0;	// восстановление значений регистров при выходе
    return;	


----

== Комментарии к Примеру
В программе `int main()` (из файла `main.cpp`) осуществляется вызов функции `Neg()`, написанной на языке ассемблера. 
Для осуществления доступа к ассемблерной функции необходимо в заголовочном файле или непосредственно в `*.срр` объявить эту функцию как внешнюю с Си связыванием, например:
`extern "C" int Neg ( int value );`
При этом она станет доступной для вызова и передачи параметров. 
Файл `step7.asm` содержит реализацию функции `Neg`. Функция возвращает значение передаваемого ей параметра с обратным знаком. 
`global _Neg: label;` - метка объявляется как глобальная. Для того чтобы из файла на Си++ можно было вызвать функцию с именем Neg, необходимо при объявлении метки в ассемблерном файле добавлять “_” перед её именем. 
 Далее следует секция кода
` begin ".text"`
`<_Neg>`
`…`
`return;`
`end ".text";`
Действия, описанные внутри секции кода, будут выполнены при вызове функции `Neg()`.
Ассемблерные функции, которые разрабатываются для последующих вызовов из программ на Си++, должны удовлетворять определённым требованиям по организации. Основное требование состоит в том, чтобы сохранять при входе и восстанавливать при выходе все общие регистры процессора за исключением `ar5` и `gr7`. В отдельных случаях, которые будут описаны ниже, регистр `gr6` также может быть изменён.
Первой инструкцией любой ассемблерной функции, в которую передаются входные параметры, должна быть инструкция 
`ar5 = ar7 – 2;`
В регистр `ar5` помещается указатель на место в стеке, ниже которого находятся параметры вызова функции. 
Адресный регистр `ar7` используется процессором в качестве указателя стека. Это означает, что `ar7` модифицируется автоматически, когда происходит вызов функции или прерывания, возврат из функции или прерывания. При вызове функции в стек заносятся ее входные параметры, а также регистры  - `pc` и `pswr` (более подробно см. документ “Конвенция о вызовах функций”). Регистр `ar7` будет указывать на свободное место в стеке. 
Для корректной работы программы требуется сохранять в стеке те регистры, которые будут использованы в теле функции. Команда 
`push ar0,gr0;`
записывает регистровую пару в вершину стека. Настоятельно рекомендуется записывать в стек 64-разрядные слова (например, регистровые пары), чтобы оставлять указатель на вершину стека четным. 
Подробнее о работе со стеком см. раздел 5.1.4 Команды работы со стеком Описания Языка Ассемблера для NM6403. 
`gr0 = [--ar5];` - в регистр gr0 помещается значение параметра функции.
`gr7 = - gr0;` - значение, возвращаемое функцией, должно быть записано в регистр gr7.
`pop ar0, gr0;` - команда чтения регистровой пары из вершины стека. 
return; - команда возврата из функции.


== Компиляция Примера 
Для компиляции примера необходимо в командной строке ввести команду: 
`nmcc -g -m Step7.asm main.cpp –oStep7.abs`
Среди входных параметров компилятора `nmcc` встречается файл с расширением .cpp. Компилятор воспринимает его, как текст на языке Си++ и в этом случае при редактировании связей автоматически добавляет библиотеку времени выполнения Си (`libc.lib`), поэтому её имя в командной строке может быть опущено.
