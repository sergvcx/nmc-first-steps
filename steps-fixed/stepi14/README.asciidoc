=  Методы Оптимизации Программ
В данной главе содержится описание основных подходов, используемых при оптимизации ассемблерного кода, оптимальном размещении различных фрагментов кода и данных по различным областям внешней памяти процессора, распределении ресурсов между параллельно выполняемыми инструкциями.
Система команд процессоров семейства NMC содержит набор векторных инструкций, выполняющихся в течение нескольких тактов (от одного до тридцати двух). Кроме того, в процессоре существует ряд вычислительных блоков, которые могут работать независимо. Это обстоятельство позволяет процессору выполнять параллельно несколько векторных и скалярных инструкций. Однако для того, чтобы добиться их параллельного выполнения, должны быть созданы определённые условия. Эти условия создаются разработчиком при проектировании программы.  Главное правило, которому необходимо следовать:

[IMPORTANT]
====
	Несколько процессорных инструкций выполняются параллельно только в том случае, если они используют непересекающиеся ресурсы процессора.
====

Это правило относится только к последовательности векторных инструкций или к векторной инструкции и выполняемым на её фоне скалярным инструкциям. Сами по себе скалярные инструкции выполняются строго последовательно.  
Далее в разделах данной главы приводятся примеры, показывающие, какие факторы необходимо учитывать при написании программы, для того, чтобы заставить векторные инструкции выполняться параллельно.



== Оптимизация Ассемблерного Кода
Исходный текст примера, используемого в данном уроке, содержится в файле `step14.S` в каталоге: `steps-fixed/stepi014`
Пример содержит описание основных подходов, используемых для оптимизации ассемблерного кода. Оптимизация программы разбирается на примере копирования блока данных при помощи векторного процессора.

*Файл “step14.S”*
[code.S]
----
include::step14.S[]
----

== Комментарии к Примеру
Для того чтобы ассемблерная программа выполнялась более эффективно, при её написании необходимо придерживаться правил, перечисленных ниже:


=== Размещение Обрабатываемых Массивов на Разных Шинах Данных
Если функция обрабатывает входной массив, а результат обработки записывает в выходной массив, то во многих случаях удобно определять входной и выходной массивы в разных секциях данных. В этом случае появляется возможность расположить входной и выходной буфера в разных банках памяти, и тем самым обеспечить параллельное чтение исходных данных и сохранение результатов вычислений.
В примере к данному уроку два массива А и С объявлены в разных секциях, что позволит разместить их на разных шинах данных (имеются в виду шины, соединяющие процессор с внешней памятью). Информация о том, как определить размещение секций по банкам памяти, содержится ниже в разделе 2.2.Использование Файла Конфигурации на стр. 2-4

// === Использование Псевдокоманд .branch и .wait
// В язык ассемблера введены две директивы, с помощью которых можно разрешить или запретить параллельное выполнение инструкций. 
// Директива `.branch` позволяет включить режим параллельного исполнения инструкций процессора. Бит параллельности устанавливается равным единице во всех следующих за псевдокомандой инструкциях процессора до тех пор, пока не будет достигнут конец файла или не будет встречена директива `.wait`. По умолчанию бит параллельности сброшен в 0, то есть параллельное выполнение векторных команд запрещено.
// Директива `.wait` устанавливает бит параллельности в 0. В результате каждая векторная инструкция процессора, прежде чем выполниться, будет дожидаться выполнения предыдущей.

=== Две Группы Адресных Регистров
Процессор NM6403 имеет два устройства генерации адреса, что позволяет одновременно адресоваться по двум адресам на внешней памяти. Каждый из генераторов содержит по четыре адресных регистра, первый – регистры `ar0..ar3`, второй – `ar4..ar7`.
Для  того чтобы две векторных инструкции, содержащие обращение к внешней памяти, выполнялись параллельно, необходимо, чтобы они использовали разные адресные генераторы. На программном уровне это означает, что если одна из инструкций для адресации использует регистр `ar2`, то вторая должна использовать какой-либо регистр из диапазона `ar4..ar6` (регистр `ar7` хранит адрес вершины стека). Только в этом случае две векторных инструкции могут выполняться параллельно (с учетом выше названных правил).

Если вернуться к примеру, то для параллельного выполнения инструкций
```
rep 16 data = [ar0++] with data;
rep 16 [ar4++] = afifo;
```
требуется удовлетворить 3 условия:
1)	В начале тела функции указать директиву .branch
2)	Использовать адресные регистры из разных регистровых групп (`ar0` из одной группы, `ar4` из другой).
3)	Расположить входной и выходной массивы в банках памяти, расположенных на разных шинах данных (`local` и `global`).
Косвенно обе инструкции используют регистр-контейнер `afifo`. Однако он представляет собой двухпортовый буфер, поэтому векторные инструкции могут параллельно записывать и считывать информацию из него.

[NOTE]
====
Возможны случаи, когда векторные инструкции не могут выполняться параллельно, например инструкции
```
rep 32 data = [ar0++] with data + afifo;
rep 32 [ar4++] = afifo;
```
не выполняются параллельно ни при каких условиях, так как первая инструкция использует afifo на чтение и запись одновременно.
====


== Использование Файла Конфигурации
Файл конфигурации используется редактором связей для того, чтобы разместить коды и данные исполняемой программы по физическим адресам, определённым в конкретной конфигурации вычислительного устройства.
Файл имеет расширение `.lds` 
Подробное описание файла конфигурации, его структура и синтаксис описаны в 
https://home.cs.colorado.edu/~main/cs1300/doc/gnu/ld_3.html

