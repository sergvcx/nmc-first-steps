=  Методы Оптимизации Программ
В данной главе содержится описание основных подходов, используемых при оптимизации ассемблерного кода, оптимальном размещении различных фрагментов кода и данных по различным областям внешней памяти процессора, распределении ресурсов между параллельно выполняемыми инструкциями.
Система команд процессора NM6403 содержит набор векторных инструкций, выполняющихся в течение нескольких тактов (от одного до тридцати двух). Кроме того, в процессоре существует ряд вычислительных блоков, которые могут работать независимо. Это обстоятельство позволяет процессору выполнять параллельно несколько векторных и скалярных инструкций. Однако для того, чтобы добиться их параллельного выполнения, должны быть созданы определённые условия. Эти условия создаются разработчиком при проектировании программы.  Главное правило, которому необходимо следовать:

[IMPORTANT]
====
	Несколько процессорных инструкций выполняются параллельно только в том случае, если они используют непересекающиеся ресурсы процессора.
====

Это правило относится только к последовательности векторных инструкций или к векторной инструкции и выполняемым на её фоне скалярным инструкциям. Сами по себе скалярные инструкции выполняются строго последовательно.  
Далее в разделах данной главы приводятся примеры, показывающие, какие факторы необходимо учитывать при написании программы, для того, чтобы заставить векторные инструкции выполняться параллельно.



= 2.1 Урок 14: Оптимизация Ассемблерного Кода
Исходный текст примера, используемого в данном уроке, содержится в файле `step14.asm` в каталоге: `..\Tutorial\Step14`
Пример содержит описание основных подходов, используемых для оптимизации ассемблерного кода. Оптимизация программы разбирается на примере копирования блока данных при помощи векторного процессора.

*Файл “step14.S”*
[code,asm]
----
include::step14.S[]
----

== Комментарии к Примеру
Для того чтобы ассемблерная программа выполнялась более эффективно, при её написании необходимо придерживаться правил, перечисленных ниже:


=== Размещение Обрабатываемых Массивов на Разных Шинах Данных
Если функция обрабатывает входной массив, а результат обработки записывает в выходной массив, то во многих случаях удобно определять входной и выходной массивы в разных секциях данных. В этом случае появляется возможность расположить входной и выходной буфера в разных банках памяти, и тем самым обеспечить параллельное чтение исходных данных и сохранение результатов вычислений.
В примере к данному уроку два массива А и С объявлены в разных секциях, что позволит разместить их на разных шинах данных (имеются в виду шины, соединяющие процессор с внешней памятью). Информация о том, как определить размещение секций по банкам памяти, содержится ниже в разделе 2.2.Использование Файла Конфигурации на стр. 2-4

=== Использование Псевдокоманд .branch и .wait
В язык ассемблера введены две директивы, с помощью которых можно разрешить или запретить параллельное выполнение инструкций. 
Директива `.branch` позволяет включить режим параллельного исполнения инструкций процессора. Бит параллельности устанавливается равным единице во всех следующих за псевдокомандой инструкциях процессора до тех пор, пока не будет достигнут конец файла или не будет встречена директива `.wait`. По умолчанию бит параллельности сброшен в 0, то есть параллельное выполнение векторных команд запрещено.
Директива `.wait` устанавливает бит параллельности в 0. В результате каждая векторная инструкция процессора, прежде чем выполниться, будет дожидаться выполнения предыдущей.

=== Две Группы Адресных Регистров
Процессор NM6403 имеет два устройства генерации адреса, что позволяет одновременно адресоваться по двум адресам на внешней памяти. Каждый из генераторов содержит по четыре адресных регистра, первый – регистры `ar0..ar3`, второй – `ar4..ar7`.
Для  того чтобы две векторных инструкции, содержащие обращение к внешней памяти, выполнялись параллельно, необходимо, чтобы они использовали разные адресные генераторы. На программном уровне это означает, что если одна из инструкций для адресации использует регистр `ar2`, то вторая должна использовать какой-либо регистр из диапазона `ar4..ar6` (регистр `ar7` хранит адрес вершины стека). Только в этом случае две векторных инструкции могут выполняться параллельно (с учетом выше названных правил).

Если вернуться к примеру, то для параллельного выполнения инструкций
`rep 16 data = [ar0++] with data;`
`rep 16 [ar4++] = afifo;`
требуется удовлетворить 3 условия:
1)	В начале тела функции указать директиву .branch
2)	Использовать адресные регистры из разных регистровых групп (`ar0` из одной группы, `ar4` из другой).
3)	Расположить входной и выходной массивы в банках памяти, расположенных на разных шинах данных (`local` и `global`).
Косвенно обе инструкции используют регистр-контейнер `afifo`. Однако он представляет собой двухпортовый буфер, поэтому векторные инструкции могут параллельно записывать и считывать информацию из него.

[NOTE]
====
Возможны случаи, когда векторные инструкции не могут выполняться параллельно, например инструкции
`rep 32 data = [ar0++] with data + afifo;`
`rep 32 [ar4++] = afifo;`
не выполняются параллельно ни при каких условиях, так как первая инструкция использует afifo на чтение и запись одновременно.
====

== Компиляция Примера 
Для компиляции примера необходимо ввести в командной строке:
`nmcc Step14.asm Libc.lib -m -cstep14.cfg`


= 2.2 Использование Файла Конфигурации
Файл конфигурации используется редактором связей для того, чтобы разместить коды и данные исполняемой программы по физическим адресам, определённым в конкретной конфигурации вычислительного устройства.
Подробное описание назначения файла конфигурации, его структура и синтаксис описаны в разделе 3.11 Файл Конфигурации документа Программное Обеспечение NeuroMatrix NM6403. Справочное руководство.
Ниже приводится файл конфигурации для данного примера, и даются краткие пояснения по его структуре.


*Файл “Step14.cfg”*
[code,asm]
----
include::Step14.cfg[]
----
Любой файл конфигурации состоит из трёх секций: 
• секция `MEMORY`, где задаётся конфигурация физической памяти устройства, а именно, её адреса и объём. Здесь необязательно указывать всю имеющуюся физическую память, а только ту его часть, которая будет доступна пользовательской программе. Например, в банках памяти `local0` и `global0` начальные области выделены под служебную информацию, поэтому они исключены из доступной памяти, и редактор связей никогда не разместит там код пользовательской программы.
• секция `SEGMENTS`, в которой определяется принадлежность программных сегментов к тем или иным банкам физической памяти.
• секция `SECTIONS`, где перечислены секции кода и данных программы, и определено, какому сегменту они принадлежат. Секции располагаются в сегменте в том порядке, в котором они перечислены. 
Понятие сегмента введено на этапе сборки программы редактором связей. Сегмент используется для упрощения загрузки программы. Секции, располагаясь в сегменте, составляют целый блок данных и кода, который за один раз может быть загружен в память устройства по заданному адресу.
Существует несколько служебных секций, в основном обусловленных требованиями стандарта Си++. Это следующие секции:
`.init` – содержит коды инициализации глобальных статических объектов, её код исполняется до вызова функции main().
`.fini` – деструкторы глобальных статических объектов, её код выполняется сразу после выполнения пользовательской программы.
.text – основная секция, содержащая коды программы.
`.data` – секция глобальных инициализированных данных.
.bss – секция глобальных неинициализированных данных.
`.stack` – секция, содержащая стек программы.
.heap – секция кучи для динамически выделяемой памяти, расположена где указано в файле конфигурации.
`.heap1` – секция кучи для динамически выделяемой памяти, расположена где указано в файле конфигурации.
Если какие-то из пользовательских или служебных секций не упомянуты в файле конфигурации, но в то же время присутствуют в программе, редактор связей автоматически разместит их в первом сегменте, указанном в секции SEGMENTS.


