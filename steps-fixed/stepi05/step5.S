.global __main            // объявление глобальной метки.

.p2align 3            	  // директива для выравнивания секции по  чётному адресу.
	
.section .data.MyData     // секция инициализированных данных

	// начальное значение для заполнения массива
	AA: .quad 0x100000000
	// инкремент для первого цикла
	BB: .quad 0x200000002
	// инкремент для второго цикла
	CC: .quad 0x4000000040
	


.section .bss.MyData1     // секция неинициализированных данных.
	.p2align 3		             // директива для выравнивания начала массива по чётному адресу.    
    // массив из 256-ти 32-х разрядных элементов, который будет заполнен возрастающими 
    // значениями от 0 до 255
	.global A
	A:  .space  256<<2
	
	
.section .text.AAA        // начало секции кода.
__main:	
    ar0     = AA;         // в ar0 загружается адрес АА (АА = 100000000hl)
    ar4     = BB;         // в ar4 загружается адрес ВВ (ВВ = 200000002hl)
    ar1,gr1 = A;          // в ar1 и в gr1 загружается адрес буфера A 
    gr2     = 31;         // счетчик цикла
		
#if __NM4__==0
	nb1 = 80000000h;  // разбиение матрицы на два столбца по 32 бита
#else
	sir = 80000000h;  // разбиение матрицы на два столбца по 32 бита
	nb1 = sir;
#endif 

    wtw;                  // копирование содержимого теневого регистра nb1 в 
                          // рабочий nb2
		
    // в ram записывается инкремент, который будет добавляться в цикле к текущему
    // значению afifo для получения новых значений заполнителя.
    rep 1 ram = [ar4];
    // в векторный процессор заносится первое значение заполнителя.
    rep 1 data = [ar0] with data;
	
    gr2--;                // установка флагов для первого вхождения в цикл.
Loop:	
	if > delayed goto Loop with gr2--;
    // заполняются первые 64 элемента выходного массива
    rep 1 [ar1++] = afifo with afifo + ram;
	nul;
	

    rep 1 [ar1++] = afifo;// выгрузка в память последнего значения из afifo
    ar1 = gr1;            // возвращение в начало массива
		
    ar0 = CC;             // в ar0 загружается адрес CC (CC = 4000000040hl)
		
    // в ram записывается инкремент, который будет добавляться в цикле к текущему
    // значению afifo для получения новых значений заполнителя.
    rep 32 ram = [ar0];
    // в векторный процессор заносятся первые значения заполнителя из А.
	gr2 = 3;              // счётчик для второго цикла
	ar2 = gr1 with gr2--; // ar2 устанавливается в начало массива и установка флагов для контроля обнуления счетчика
    rep 32 data = [ar2++] with data;
	
Loop1:	
	if > delayed goto Loop1 with gr2--;
    // массив A заполняется возрастающими значениями
    // за один цикл обрабатываются 64 32-разрядных элемента.
    rep 32 [ar1++] = afifo with afifo + ram;
	nul;
	
    // последние 64 элемента массива сохраняются в памяти
    rep 32 [ar1++] = afifo;
	
	return;	

