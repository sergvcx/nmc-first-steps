= Использование Циклического Сдвигателя на ВП
Исходный текст примера, используемого в данном уроке, содержится в файле `step11.asm` в каталоге: `..\Tutorial\Step11`.
Пример демонстрирует использование операции циклического сдвига на векторном процессоре при работе с бинарными элементами. Программа изменяет порядок битов во входном 64-разрядном слове данных на противоположный. Меняются местами 0 ой и 63 ий биты, 1 ый и 62 ой, и т.д. 



*Файл “main.cpp”*
[code,cpp]
----
include::main.cpp[]
----


*Файл “Step11.S”*
[code,asm]
----
include::Step11.S[]
----


== Комментарии к Примеру
Для заполнения массива весовых коэффициентов в примере используются константные выражения, вычисляемые на этапе компиляции. Компилятор способен вычислять константные выражения, результатом которых является 64-разрядная константа для заполнения ячеек памяти.
В примере используется максимально возможное разбиение матриц:  64 столбца и 32 строки. При этом вектора входных данных разбиваются на тридцать два элемента разрядностью по 2 бита, а результирующий вектор состоит из шестидесяти четырёх бинарных элементов.
Инструкция
`rep 1 ram = [--ar5] with vsum , data, 0;`
обращается непосредственно в стек, считывает входной вектор, загружает его в `ram`, а пока он проходит по шине данных дублирует его и отправляет на вход X матричного устройства умножения.
Инструкция
`rep 1 with vsum , shift ram, afifo;`
при помощи ключевого слова `shift` активирует циклический сдвигатель, и вектор данных из `ram` при проходе через него сдвигается на один бит вправо, так что нулевой бит становится шестьдесят третьим, первый нулевым, второй первым, и т.д. 
Циклический сдвиг может применяться только к векторам, подаваемым на вход X матричного устройства умножения. Разбиение вектора на элементы никак не учитывается, так что младший бит одного элемента после сдвига становится старшим битом его соседа справа. Если такое поведение сдвигателя мешает правильной обработке данных, можно замаскировать отдельные биты. В случае рассматриваемого примера в дополнительном маскировании нет необходимости, поскольку при таком разбиении матрицы (32 строки и 64 столбца) обрабатываются только чётные биты элементов входного вектора, нечётные игнорируются.
Таким образом, входной вектор дважды проходит через матрицу, сначала обрабатываются его чётные биты, а затем, путём сдвига нечётные биты становятся чётными, и также подвергаются обработке.

== Компиляция Примера 
Для компиляции примера необходимо в командной строке ввести команду: 
`nmcc -g -m Step11.asm main.cpp –oStep11.abs`


