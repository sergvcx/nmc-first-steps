= Передаваемые и Возвращаемые Значения Типа LONG
Исходный текст примера, используемого в данном уроке, содержится в файле `step8.S` в каталоге: `steps-fixed/stepi08`.
Пример демонстрирует возможность использования 64-разрядных переменных для передачи в качестве параметров в ассемблерную функцию и получения в качестве возвращаемого значения. 

Файл “main.cpp”
[code,cpp]
----
include::main.cpp[]
----
Файл “step8.S”
[code.S]
----
include::step8.S[]
----


== Комментарии к Примеру
Пример состоит из двух частей, выполняющих одно и то же действие – изменение знака 64-разрядного числа.

=== Замена Знака Числа на Скалярном Процессоре 
Функция начинается с сохранения в `ar5` адреса входных параметров и сохранения используемых в теле функции регистров. Далее загружается входной параметр. Так как он имеет тип `long` (64-бита), то необходимо использовать регистровую пару: младшее слово параметра попадает в `ar0`, старшее – в `gr0`: 

`ar0,gr0 = [--ar5];`
Поскольку адресный регистр не может использоваться в арифметических операциях, его значение необходимо скопировать в регистр общего назначения: 
`gr1 = ar0;`
Инструкция 
`gr1 = 0 with gr7 = - gr1;`
в левой части обнуляет регистр gr1, а в правой выполняется операция изменения знака регистра `gr1` и результат загружается в `gr7`. Регистр `gr1` используется в левой и в правой частях инструкции. В этом случае, для понимания того, какие же значения и в какое время принимает этот регистр, необходимо руководствоваться следующим правилом: 


[WARNING]
====
Левая и правая части инструкции выполняются одновременно, а в качестве исходных используются значения регистров, которые хранились в них до выполнения данной инструкции.
====

Таким образом, в правой части инструкции используется старое значение регистра `gr1`, а в результате выполнения инструкции ему присваивается новое значение. Более подробно проблема использования одного и того же регистра в обеих частях инструкции описывается в приложении A.3.Использование Регистров в Обеих Частях Скалярной Инструкции.
Операция `gr6 = gr1 - gr0 - 1 + carry`; осуществляет вычитание значений двух регистров с учетом значения флага переноса (Подробнее см. раздел 5.1.11 Арифметические операции Описания Языка Ассемблера для NM6403). Из значения регистра `gr1(gr1 = 0)` вычитается значение `gr0`(старшее слово входного  параметра функции), при этом учитывается состояние бита переноса, выставленное предыдущей операцией. 
Старшее слово результата помещается в `gr6`. В случае, если функция возвращает 64-разрядное значение, младшая часть результата должна загружаться в `gr7`, старшая – в `gr6`.


=== Замена Знака Числа на Векторном Процессоре
Инструкции `SET nb1 , 0; wtw;` определяют разбиение 64-разрядного слова на элементы. В данном случае, слово, поступающее на вход векторного АЛУ, будет представлено, как один элемент, и перенос битов будет осуществляться в пределах 64 разрядов.
`rep 1 data = [--ar5] with 0-data;` - векторная инструкция, осуществляющая арифметическую операцию на векторном АЛУ (разность операндов X и Y, где на операнд Х подан нулевой вектор). Операция изменяет знак входного параметра функции. 
rep 1 [ar1] = afifo; - результат из `afifo` помещается в переменную `А`, адрес которой находится в `ar1`.
Далее старшая и младшая части `А` копируются в регистры `gr6` и `gr7` соответственно.  

