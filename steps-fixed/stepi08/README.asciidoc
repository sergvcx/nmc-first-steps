= 1.12 Урок 8: Передаваемые и Возвращаемые Значения Типа LONG
Исходный текст примера, используемого в данном уроке, содержится в файле `step8.asm` в каталоге: `..\Tutorial\Step8`.
Пример демонстрирует возможность использования 64-разрядных переменных для передачи в качестве параметров в ассемблерную функцию и получения в качестве возвращаемого значения. 

Файл “main.cpp”
[code,cpp]
----
extern "C" {
	// функции Neg_Scal и Neg_Vect объявлены как внешние с Си-связыванием
	long Neg_Scal ( long value );
	long Neg_Vect ( long value );
}

int main()
{
	long a = 0x2222222211111111;
	// вызов функции Neg_Scal(a) с параметром а и запись значения, 
    // возвращаемого функцией, в переменную b.
	long b = Neg_Scal(a);
	// вызов функции Neg_Vect(a) с параметром а и запись значения, 
    // возвращаемого функцией, в переменную c.
	long c = Neg_Vect(a);
	return int(b-c);
}

----
Файл “step8.S”
[code,asm]
----
.global _Neg_Scal
.global _Neg_Vect

.section .bss.my_data	
    A: .quad          // объявляется 64-разрядная переменная ј
	
.text
// функция Neg_Scal на скалярном процессоре выполняет обработку 64-разрядного числа 
// заменяя его знак на противоположный
_Neg_Scal:	
    ar5 = ar7 - 2;    // сохраняется указатель стека
    push ar0, gr0;    // сохраняются регистровые пары в стеке
    push ar1, gr1;	
    ar0,gr0 = [--ar5];// из стека считывается входной параметр функции
    gr1 = ar0;        // в gr1 помещается младшшее слово параметра
    	
    // в gr1записывается 0 и одновременно в gr7 помещается младшая часть параметра 
    // функции с обратным знаком
    gr1 = 0 with gr7 = - gr1;
    // вычитание значений двух регистров с учетом значения флага переноса
    gr6 = gr1 - gr0 - 1 + carry;
	
    pop ar1, gr1;     // восстановление регистровых пар из стека
    pop ar0, gr0;	
    return;           // возвращаемое значение передаЄтся в регистрах: 
			          //gr6 - старшая часть, gr7 - младшая чать
		
		
// функция Neg_Vect на векторном процессоре выполняет обработку 64-разрядного числа 
// заменяя его знак на противоположный
_Neg_Vect:
    ar5 = ar7 - 2;    // сохраняется указатель стека
    push ar0, gr0;    // сохраняются регистровые пары в стеке
    push ar1, gr1;	
    ar1 = A;          // в ar1загружается адрес ј 
	
#if __NM4__== 0
    nb1 = 0;          // nb1 определяет разбиение на элементы 64-разрядного вектора, участвующего  в арифметических операциях на векторном ј (nb1 = 0 - разбиения нет).
#else
    sir = 0;          // nb1 определяет разбиение на элементы 64-разрядного вектора, участвующего  в арифметических операциях на векторном ј (nb1 = 0 - разбиения нет).
    nb1 = sir;
#endif


    wtw;              // копирование содержимого теневого регистра nb1 в 
                      // рабочий nb2
    // изменение знака 64-разрядного числа
    rep 1 data = [--ar5] with 0-data;
    // результат помещается в память по адресу,  хранящемуся в регистре ar1
    rep 1 [ar1] = afifo;
    gr7 = [ar1++];    // младшая часть результата копируется ил памяти в 
                      // регистр gr7
    gr6 = [ar1++];    // старшая часть результата копируется ил памяти в 
                      // регистр gr6
    pop ar1, gr1;     // восстановление регистровых пар из стека
    pop ar0, gr0;	
    return;	
		
	

----


== Комментарии к Примеру
Пример состоит из двух частей, выполняющих одно и то же действие – изменение знака 64-разрядного числа.

=== Замена Знака Числа на Скалярнм Процессоре 
Функция начинается с сохранения в `ar5` адреса входных параметров и сохранения используемых в теле функции регистров. Далее загружается входной параметр. Так как он имеет тип `long` (64-бита), то необходимо использовать регистровую пару: младшее слово параметра попадает в `ar0`, старшее – в `gr0`: 
`ar0,gr0 = [--ar5];`
Поскольку адресный регистр не может использоваться в арифметических операциях, его значение необходимо скопировать в регистр общего назначения: 
`gr1 = ar0;`
Инструкция 
``gr1 = 0 with gr7 = - gr1`; `
в левой части обнуляет регистр gr1, а в правой выполняется операция изменения знака регистра `gr1` и результат загружается в `gr7`. Регистр `gr1` используется в левой и в правой частях инструкции. В этом случае, для понимания того, какие же значения и в какое время принимает этот регистр, необходимо руководствоваться следующим правилом: 


[IMPORTANT]
====
Левая и правая части инструкции выполняются одновременно, а в качестве исходных используются значения регистров, которые хранились в них до выполнения данной инструкции.
====

Таким образом, в правой части инструкции используется старое значение регистра `gr1`, а в результате выполнения инструкции ему присваивается новое значение. Более подробно проблема использования одного и того же регистра в обеих частях инструкции описывается в приложении A.3.Использование Регистров в Обеих Частях Скалярной Инструкции.
Операция `gr6 = gr1 - gr0 - 1 + carry`; осуществляет вычитание значений двух регистров с учетом значения флага переноса (Подробнее см. раздел 5.1.11 Арифметические операции Описания Языка Ассемблера для NM6403). Из значения регистра `gr1(gr1 = 0)` вычитается значение `gr0`(старшее слово входного  параметра функции), при этом учитывается состояние бита переноса, выставленное предыдущей операцией. 
Старшее слово результата помещается в `gr6`. В случае, если функция возвращает 64-разрядное значение, младшая часть результата должна загружаться в `gr7`, старшая – в `gr6`.


=== Замена Знака Числа на Векторном Процессоре
Инструкции `nb1 = 0; wtw;` определяют разбиение 64-разрядного слова на элементы. В данном случае, слово, поступающее на вход векторного АЛУ, будет представлено, как один элемент, и перенос битов будет осуществляться в пределах 64 разрядов.
`rep 1 data = [--ar5] with 0-data;` - векторная инструкция, осуществляющая арифметическую операцию на векторном АЛУ (разность операндов X и Y, где на операнд Х подан нулевой вектор). Операция изменяет знак входного параметра функции. 
rep 1 [ar1] = afifo; - результат из `afifo` помещается в переменную `А`, адрес которой находится в `ar1`.
Далее старшая и младшая части `А` копируются в регистры `gr6` и `gr7` соответственно.  

== Компиляция Примера 
Для компиляции примера необходимо в командной строке ввести команду: 
`nmcc -g -m Step8.asm main.cpp –oStep8.abs`
