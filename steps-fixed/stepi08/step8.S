.global _Neg_Scal
.global _Neg_Vect

.p2align 3            	  	// директива для выравнивания секции по  чётному адресу.	
.section .bss.my_data	
    A: .space 1<<3    		// выделяется место для 64-разрядной переменной ј

.macro SET reg,val
#if __NM4__== 0
	\reg = \val; 
#else
	sir = \val; 
	\reg = sir;   
#endif
.endm
	
.text
// функция Neg_Scal на скалярном процессоре выполняет обработку 64-разрядного числа 
// заменяя его знак на противоположный
_Neg_Scal:	
    ar5 = ar7 - 2;    // сохраняется указатель стека
    push ar0, gr0;    // сохраняются регистровые пары в стеке
    push ar1, gr1;	
    ar0,gr0 = [--ar5];// из стека считывается входной параметр функции
    gr1 = ar0;        // в gr1 помещается младшее слово параметра
    	
    // в gr1записывается 0 и одновременно в gr7 помещается младшая часть параметра 
    // функции с обратным знаком
    gr1 = 0 with gr7 = - gr1;
    // вычитание значений двух регистров с учетом значения флага переноса
    gr6 = gr1 - gr0 - 1 + carry;
	
    pop ar1, gr1;     // восстановление регистровых пар из стека
    pop ar0, gr0;	
    return;           // возвращаемое значение передаЄтся в регистрах: 
			          //gr6 - старшая часть, gr7 - младшая часть
		
		
// функция Neg_Vect на векторном процессоре выполняет обработку 64-разрядного числа 
// заменяя его знак на противоположный
_Neg_Vect:
    ar5 = ar7 - 2;    // сохраняется указатель стека
    push ar0, gr0;    // сохраняются регистровые пары в стеке
    push ar1, gr1;	
    ar1 = A;          // в ar1загружается адрес ј 
	
   SET nb1 , 0          // nb1 определяет разбиение на элементы 64-разрядного вектора, участвующего  в арифметических операциях на векторном ј (nb1 = 0 - разбиения нет).

    wtw;              // копирование содержимого теневого регистра nb1 в 
                      // рабочий nb2
    // изменение знака 64-разрядного числа
    rep 1 data = [--ar5] with 0-data;
    // результат помещается в память по адресу,  хранящемуся в регистре ar1
    rep 1 [ar1] = afifo;
    gr7 = [ar1++];    // младшая часть результата копируется ил памяти в 
                      // регистр gr7
    gr6 = [ar1++];    // старшая часть результата копируется ил памяти в 
                      // регистр gr6
    pop ar1, gr1;     // восстановление регистровых пар из стека
    pop ar0, gr0;	
    return;	
		
	
