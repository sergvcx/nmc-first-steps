= Копирование Массива Данных на Векторном Процессоре
Исходный текст примера, используемого в данном уроке, содержится в файле `step4а.S` в каталоге: `steps-fixed/stepi04а`.
Пример демонстрирует копирование массива 32-разрядных слов с помощью скалярного процессора и векторного процессора.

*Файл “step4a.S”*
[code.S]
----
include::step4a.S[]
----



== Комментарии к Примеру
Копирование с помощью скалярного процессора подробно комментировалось в предыдущем уроке, поэтому здесь особое внимание будет уделено работе с векторным процессором.
Копирование с помощью векторного процессора:
Аналогично скалярной векторная инструкция состоит из левой и правой частей. В левой части содержится команда обращения к памяти на чтение/запись, а в правой операции на векторном процессоре. 
Левая часть инструкции 
`rep 8 data = [ar0++] with data;` 

осуществляет чтение значений из внешней памяти по адресу, хранящемуся в адресном регистре, в логический регистр-контейнер data с пост-инкрементацией адресного регистра. В правой части инструкции данные, проходящие по шине данных, поступают на вход X операционного узла векторного процессора и, в данном случае, остаются без изменений. Правую часть инструкции можно представить как краткую запись выражения 
`‘with data or 0’`. 
Результаты выполнения векторной инструкции попадают в регистр-контейнер afifo.
Обязательным атрибутом векторной инструкции является количество повторений, определяющее, какое количество 64-х разрядных векторов данных обрабатывается данной инструкцией. В этом смысле векторные инструкции являются SIMD (Single Instruction Multiple Data) инструкциями, выполняя одно и то же действие над несколькими векторами данных. 
При выполнении арифметических и логических операций, необходимо определить разбиение 64-разрядных векторов, поступающих на вход векторного АЛУ,  на элементы. Это действие осуществляется с помощью регистра `nb1`. В данной программе перед векторными инструкциями следовало бы поместить команды
```
SET nb1, 0
wtw;// переписывает информацию из теневого регистра nb1 в рабочий nb2
``` 
, но поскольку выполняемая логическая операция не предполагает переноса битов, то эти команды можно опустить.
Команда 
`rep 8 [ar1++] = afifo;`  

осуществляет выгрузку данных из afifo в память с пост-инкрементацией адресного регистра. (`rep` кол-во выгружаемых слов). Нельзя выгружать данные по частям (например, сначала 4, а потом еще 4 слова), только целиком все содержимое `afifo`. Содержимое `afifo` не может быть выгружено в регистры процессора или регистровые пары, только в память.
Следует обратить внимание на несовпадении количества повторений для скалярного и векторного процессора:  количество итераций в цикле скалярного процессора равно 16, а количество повторений команд чтения/записи в векторной инструкции равно 8. Это различие возникает  в связи с тем, что при обращении к памяти на скалярном процессоре считываются/записываются 32-разрядные слова, тогда как на векторном процессоре осуществляется чтение/запись 64-разрядных слов. Таким образом, при инкрементации `[ar1++]` адресный процессор каждый раз увеличивается на два.

