= 1.10 Урок 6b: Операция Взвешенного Суммирования (Продолжение 2)
Исходный текст примера, используемого в данном уроке, содержится в файле `step6b.asm` в каталоге: `..\Tutorial\Step6b`.
Пример демонстрирует использование операции взвешенного суммирования для вычисления суммы шестидесяти четырёх 32 разрядных слов. Предполагается, что переполнения при суммировании не происходит.


*Файл “step6b.S”*
[code,asm]
----
include::step6b.S[]
----


== Комментарии к Примеру
Задачей данного примера является одновременное вычисление суммы элементов 64-х разрядного вектора. Это вычисление выполняется на устройстве умножения векторного процессора при помощи операции взвешенного суммирования. Основная идея этого преобразования поясняется на 
Рис. <<fig-sum>>:

[#fig-sum]
.Вычисление Суммы Элементов Массива 
image::sum.png[image,width=608,height=479]

Особенность данного примера состоит в том, что в рабочую матрицу загружаются не весовые коэффициенты, а данные. Записанное в `sb` значение `AAAAAAAAh` позволяет загрузить в матрицу 32 вектора, а затем за один такт сложить элементы вдоль каждого из столбцов.
Команда `rep 32 wfifo = [ar1++], ftw, wtw`; осуществляет загрузку векторов из памяти в регистр-контейнер `wfifo`. Как только первый вектор попадёт в `wfifo`, начинается его перекодирование в формат теневой матрицы (эта операция задаётся командой `ftw`). По завершению перекодирования её содержимое будет скопировано в рабочую матрицу. 
Инструкция
`rep 1 data = [ar2] with vsum , data, 0;`
выполняет суммирование всех тридцати двух строк. Вычисление производится по схеме приведённой на Рис. <<fig-sum>>. Результат операции попадает в регистр-контейнер afifo.
Инструкция 
`rep 1 [ar4] = afifo;`
выгружает результат из afifo во внешнюю память. После этого на скалярном процессоре две частичных суммы суммируются между собой, и результат возвращается в регистре `gr7`.

== Компиляция Примера 
Для компиляции примера `step6b.asm` необходимо в командной строке ввести команду: 
`nmcc -g step6b.asm libc.lib -m`


