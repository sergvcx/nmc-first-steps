= 1.14 Урок 10: Операция Арифметической Активации
Исходный текст примера, используемого в данном уроке, содержится в файле step10.asm в каталоге: `..\Tutorial\Step10`.
Пример демонстрирует выполнение операции арифметической активации на векторном процессоре. Функция `AddSaturate()` выполняет поэлементное суммирование двух байтовых массивов, состоящих из элементов, значения которых лежат в диапазоне от ` 128` до `127`. В случае переполнения функция заменяет значение на минимально возможное `0хFF(-128)` в случае отрицательного переполнения или на максимально возможное `0x7F(127)` в случае положительного переполнения.

*Файл “main.cpp”*
[code,cpp]
----
include::main.cpp[]
----


*Файл “Step12.S”*
[code,asm]
----
include::Step10.S[]
----


== Комментарии к Примеру
Вычисления в примере выполняются в два этапа, что связано с преобразованием разрядностей входных векторов. Сначала обрабатываются четыре младших элемента входных векторов, а затем четыре старших (см. Рис. <<fig-matrix_op>>). 

[#fig-matrix_op]
.Матричные Операции при Поэлементном Сложении  Векторов
image::matrix_op.png[image,width=608,height=479]

Функция выполняет следующую последовательность действий:
• Загружает веса в матрицу для выполнения преобразования разрядности, как изображено на Рис. <<fig-matrix_op>>А;
• Выполняет преобразование младших половин двух входных векторов из 8-ми в 16 разрядов и поэлементно складывает преобразованные вектора;
• Применяет арифметическую функцию активации (насыщения) для замены сумм, превысивших диапазон `–128 .. 127`, на пограничные значения диапазона;
• Выполняет обратное преобразование из 16-ти в 8 бит, как изображено на Рис. <<fig-matrix_op>>Б;
• Сохраняет результат первого прохода во внутреннем буфере `ram`;
• Выполняет аналогичные преобразования над старшими половинами входных векторов, как изображено на Рис. <<fig-matrix_op>>В и Г, а затем складывает результаты первого и второго проходов.
Переходя к особенностям реализации алгоритма необходимо обратить внимание на то, что весовые коэффициенты, хотя и принадлежат четырём разным матрицам, загружаются в `wfifo` одной командой: 
`rep 24 wfifo = [ar6++], ftw, wtw;`
Это одно из свойств `wfifo`, позволяющее добавлять и выбирать коэффициенты порциями. После того, как определена конфигурация теневой матрицы, процессор в соответствии с этой конфигурацией выбирает необходимое количество весов, преобразуя их в формат теневой матрицы. Оставшиеся в `wfifo` веса дожидаются своей очереди.
Инструкция
`rep 32 data = [ar0++], ftw with vsum , data, 0;`
совмещает в себе выполнение операции взвешенного суммирования с загрузкой новой порции весовых коэффициентов (`ftw`) в теневую матрицу.
Инструкция 
`rep 32 ftw with vsum , activate afifo, 0;`
выполняет арифметическую активацию (насыщение) набора векторов, хранящихся в `afifo`, а затем активированные данные поступают на матричное устройство умножения, где происходит возврат от 16-ти к 8-ми битам.
Несколько слов необходимо сказать об арифметической активации. Она называется арифметической, поскольку применяется только в том случае, когда на векторном АЛУ выполняется арифметическая операция, например: `activate ram + data`, или 
`0 – activate afifo`. Операция взвешенного суммирования также является арифметической, поэтому в паре с ней выполняется именно функция насыщения.
Рис. 1 8 приводит пример того, как регистр f1cr (`f2cr`) управляет арифметической функцией активации:

[#fig-activate]
.Управление Арифметической Функцией Активации
image::activate.png[image,width=608,height=479]

Выход за пределы диапазона `–128..127` в 16-разрядном числе может быть обнаружен по следующему признаку:  несовпадение значений знаковых битов. Если 16-разрядное число принадлежит определённому выше диапазону, то биты с 7-ого по 15-ый являются знаковыми (на Рис. <<fig-activate>> помечены серым). В случае если значение хотя бы одного знакового бита отличается от значения самого старшего бита (на рисунке затемнён больше остальных), можно утверждать, что это число лежит вне заданного диапазона. Этот анализ является основой функции насыщения.
В регистре `f1cr` все знаковые биты элементов данных помечаются единицами. При обработке входного вектора процессор сравнивает все его биты, расположенные под единичными битами `f1cr` с самым старшим битом элемента. Если все знаковые биты имеют одинаковое значение, то превышения диапазона не обнаружено, число пропускается через фильтр без изменений.
В случае если в данном элементе какие-то из знаковых бит отличаются от самого старшего, детектируется выход за диапазон и число заменяется максимальным или минимальным числом диапазона (опять таки в зависимости от значения старшего бита).

== Компиляция Примера 
Для компиляции примера необходимо в командной строке ввести команду: 
`nmcc -g -m Step10.asm main.cpp –oStep10.abs`

